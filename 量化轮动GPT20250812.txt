# ==============================
#  Aè‚¡ã€Œé‡èƒ½-è¾¨è¯†åº¦-å¼¹æ€§ã€è½®åŠ¨ï¼ˆæ—¥é¢‘ç‰ˆï¼‰
#  å›æµ‹åŒºé—´ï¼šè‡ªè¡Œåœ¨ç•Œé¢é€‰ 2025-01-01 è‡³ 2025-08-01
#  ä½œè€…ï¼šä¸ä½ PKæ”¶ç›Šç‡çš„é‚£ä½ğŸ˜„
# ==============================

import numpy as np
import pandas as pd

# ------------------------------
# å‚æ•°åŒºï¼ˆå¯æŒ‰éœ€å¾®è°ƒï¼‰
# ------------------------------
class G:
    # åŸºç¡€
    UNIVERSE_TOP_N = 800        # ä»å…¨å¸‚åœºæŒ‘æˆäº¤é¢TopNä½œä¸ºåŸºç¡€å€™é€‰
    HOLD_NUM        = 20        # å®é™…æŒä»“åªæ‹¿å‰20
    CASH_KEEP       = 0.03      # ç•™ç°é‡‘æ¯”ä¾‹ï¼ˆé˜²å…¨éƒ¨ä¹°ä¸æ»¡æ‰‹çš„æŠ¥é”™ï¼‰
    REBALANCE_TIME  = '09:40'   # æ¯æ—¥è°ƒä»“æ—¶ç‚¹

    # äº¤æ˜“æ§åˆ¶
    MAX_WEIGHT      = 0.08      # å•ç¥¨æœ€å¤§æƒé‡
    STOP_LOSS_PCT   = -0.08     # ä¸ªè‚¡å›æ’¤æ­¢æŸï¼ˆç›¸å¯¹æŒä»“æˆæœ¬ï¼‰
    TAKE_PROFIT_PCT =  0.18     # ä¸ªè‚¡æ­¢ç›ˆï¼ˆç›¸å¯¹æŒä»“æˆæœ¬ï¼‰
    TRAIL_PROFIT    =  0.10     # æµ®ç›ˆå›æ’¤è§¦å‘ï¼ˆè¿½è¸ªæ­¢ç›ˆï¼ŒåŸºäºæŒä»“æœ€é«˜æµ®ç›ˆå›æ’¤ï¼‰

    # é€‰è‚¡ï¼ˆä¸æ¥å…¥ç›˜ä¸­å¼‚åŠ¨ï¼Œä»…æ—¥é¢‘ï¼‰
    VOL_BOOST_WIN   = 5         # æˆäº¤é‡å‡çº¿çª—å£
    MOM_WIN         = 10        # åŠ¨é‡çª—å£ï¼ˆæ—¥ï¼‰
    VOLAT_WIN       = 20        # æ³¢åŠ¨çª—å£
    LIQ_MIN_TURN    = 0.005     # æœ€ä½æ¢æ‰‹ï¼ˆ0.5%ï¼‰
    PRICE_MIN       = 5         # æœ€ä½ä»·æ ¼è¿‡æ»¤ï¼ˆå…ƒï¼‰
    MCAP_MAX        = 150e8     # æœ€å¤§æ€»å¸‚å€¼ï¼ˆå¼¹æ€§ä¼˜å…ˆï¼Œ150äº¿ï¼‰
    MCAP_MIN        = 30e8      # æœ€å°æ€»å¸‚å€¼ï¼ˆå®¹é‡ä¸‹é™ï¼‰
g = G()

# ------------------------------
# å·¥å…·å‡½æ•°
# ------------------------------
def is_kcb(sec):
    # ç§‘åˆ›æ¿ï¼š688xxx.XSHG
    return sec.startswith('688')

def is_cyb(sec):
    # åˆ›ä¸šæ¿ï¼š300xxx.XSHE
    return sec.startswith('300')

def min_lot(sec):
    # ç§‘åˆ›æ¿æœ€å°200è‚¡ï¼Œå…¶ä½™100è‚¡
    return 200 if is_kcb(sec) else 100

def clamp(x, lo, hi):
    return max(lo, min(hi, x))

def is_listed_on(sec, dt):
    """ç”¨è¯åˆ¸åŸºç¡€ä¿¡æ¯åˆ¤æ–­åœ¨ dt å½“å¤©æ˜¯å¦ä»åœ¨å¸‚"""
    try:
        info = get_security_info(sec)
        if info is None:
            return True
        return (info.start_date is None or info.start_date <= dt.date()) and \
               (info.end_date   is None or info.end_date   >= dt.date())
    except:
        return True

def base_universe(context):
    """åˆç­›ï¼šå»é™¤ST/åœç‰Œ/é€€å¸‚/ä½ä»·"""
    stocks = list(get_all_securities(['stock'], date=context.current_dt).index)
    cd = get_current_data()
    res = []
    for s in stocks:
        d = cd[s]
        if getattr(d, 'is_st', False) or getattr(d, 'paused', False):
            continue
        if not is_listed_on(s, context.current_dt):
            continue
        lp = getattr(d, 'last_price', None)
        if lp is None or np.isnan(lp) or lp < g.PRICE_MIN:
            continue
        res.append(s)
    return res

def top_by_turnover(context, pool, n):
    """æŒ‰å‰ä¸€äº¤æ˜“æ—¥æˆäº¤é¢æ’åºï¼Œå–TopNï¼ˆä¿è¯Seriesä¸ºfloatï¼Œé¿å…æ’åºç±»å‹æ··å…¥ï¼‰"""
    if not pool:
        return []
    prev = context.previous_date
    # å–ä¸Šä¸€æ—¥çš„ moneyï¼ˆæˆäº¤é¢ï¼‰
    q = get_price(pool, end_date=prev, count=1, frequency='daily', fields=['money'], panel=False)
    # å¯èƒ½æœ‰ç¼ºå¤±ï¼Œå¡«0å¹¶è½¬float
    s = q.pivot(index='time', columns='code', values='money').iloc[-1].reindex(pool).fillna(0.0).astype(float)
    s = s.sort_values(ascending=False)
    return list(s.index[:min(n, len(s))])

def get_float_series(series_like):
    """å°†ä»»æ„Serieså®‰å…¨è½¬floatï¼Œç¼ºå¤±->0"""
    return pd.to_numeric(pd.Series(series_like).fillna(0), errors='coerce').fillna(0).astype(float)

def board_cap_ok(sec, date):
    """ç”¨èšå®½å› å­æ¥å£æ‹¿æ€»å¸‚å€¼ï¼Œæ§åˆ¶å¼¹æ€§åŒºé—´"""
    try:
        df = get_fundamentals(query(valuation.code, valuation.market_cap).filter(valuation.code==sec), date=date)
        if df is None or df.empty:
            return False
        mcap = float(df['market_cap'].iloc[0]) * 1e8  # äº¿è½¬å…ƒ
        return (g.MCAP_MIN <= mcap <= g.MCAP_MAX)
    except:
        return True  # è·å–å¤±è´¥ä¸ä¸¥æ ¼å¡æ­»

# ------------------------------
# Alpha æ¨¡å‹ï¼ˆå¯ç‹¬ç«‹å¯¹å¤–æš´éœ²ï¼‰
# ------------------------------
def alpha_rank(context, candidates, asof_date=None):
    """
    è¿”å› {sec: alpha_score}ï¼Œä»…ç”¨æ—¥é¢‘é‡ä»·ï¼ˆä¸æ¥å…¥ç›˜ä¸­å¼‚åŠ¨ï¼‰
    æŒ‡æ ‡ï¼šé‡èƒ½æ”¾å¤§ï¼ˆVOL/MA5ï¼‰ã€åŠ¨é‡ï¼ˆ10æ—¥ï¼‰ã€æ³¢åŠ¨ï¼ˆè¶Šå¤§è¶Šå¥½ä½†ä¸è¿‡åº¦ï¼‰ã€æ¢æ‰‹åˆè§„ã€æ€»å¸‚å€¼ç­›ã€‚
    """
    if not candidates:
        return {}

    if asof_date is None:
        asof_date = context.current_dt

    # æ‹‰ä¸€æ®µå†å²ä»¥ç®—æŒ‡æ ‡
    win = max(g.MOM_WIN, g.VOLAT_WIN, g.VOL_BOOST_WIN) + 1
    bars = get_price(candidates, end_date=asof_date, count=win, frequency='daily',
                     fields=['close','open','high','low','volume'], panel=False)
    if bars is None or bars.empty:
        return {}

    # ç»„ç»‡ä¸ºå®½è¡¨
    pv = lambda f: bars.pivot(index='time', columns='code', values=f)

    close = pv('close').ffill()
    volume = pv('volume').ffill()
    ret_1  = close.pct_change().fillna(0)

    # åŠ¨é‡ï¼šè¿‡å»10æ—¥ç´¯ç§¯æ”¶ç›Š
    mom = (close / close.shift(g.MOM_WIN) - 1).iloc[-1].reindex(close.columns)
    mom = get_float_series(mom)

    # é‡èƒ½æ”¾å¤§ï¼šæœ€è¿‘ä¸€æ—¥æˆäº¤é‡ / 5æ—¥å‡é‡
    vol_ma5 = volume.rolling(g.VOL_BOOST_WIN).mean()
    vol_boost = (volume.iloc[-1] / (vol_ma5.iloc[-1].replace(0, np.nan))).fillna(0)
    vol_boost = get_float_series(vol_boost)

    # æ³¢åŠ¨ï¼šè¿‘20æ—¥æ—¥æ”¶ç›Šçš„æ ‡å‡†å·®
    vola = ret_1.rolling(g.VOLAT_WIN).std().iloc[-1]
    vola = get_float_series(vola)

    # å½“å‰æ¢æ‰‹ç‡ï¼ˆç”¨è¿‘1æ—¥è¿‘ä¼¼ï¼švolume / æµé€šè‚¡æœ¬ï¼‰ï¼Œè¿™é‡Œç®€åŒ–ç”¨æˆäº¤é‡/è¿‘5æ—¥å‡é‡çš„ç›¸å¯¹é‡èƒ½æ›¿ä»£åšé—¨æ§›
    # ä¹Ÿå¯ç”¨ get_fundamentals(stock_indicators.turnover_ratio) æ‰¹é‡è·å–ï¼Œè€ƒè™‘æ€§èƒ½æˆ‘ç”¨é—¨æ§›è¿‡æ»¤ï¼š
    turn_ok = vol_boost >= (g.LIQ_MIN_TURN * 200)  # ç»éªŒæ˜ å°„ï¼š0.5%æ¢æ‰‹â‰ˆvol_boost>1~2ï¼Œç»™ä¸ªå®½ä¸€ç‚¹çš„é˜ˆ

    # æ€»å¸‚å€¼ç­›ï¼ˆå¼¹æ€§ï¼‰â€”â€”é€ä¸ªåˆ¤æ–­
    cap_mask = pd.Series({s: board_cap_ok(s, asof_date) for s in close.columns})

    # è‘£äº‹ä¼šå±æ€§åŠ åˆ†ï¼š20cmä¼˜å…ˆï¼ˆç§‘åˆ›/åˆ›ä¸šï¼‰ï¼Œ10cmé€€è€Œæ±‚å…¶æ¬¡ï¼ˆè¾¨è¯†åº¦çœ‹æˆäº¤é¢Topé‡Œè‡ªç„¶å¥½ï¼‰
    board_bonus = pd.Series({s: (1.0 if (is_kcb(s) or is_cyb(s)) else 0.5) for s in close.columns})

    # å½’ä¸€åŒ–
    def zscore(x):
        x = get_float_series(x)
        if x.std() == 0:
            return x * 0
        return (x - x.mean()) / (x.std() + 1e-12)

    score = 0.6 * zscore(vol_boost) + 0.3 * zscore(mom) + 0.3 * zscore(vola) + 0.2 * board_bonus
    # ç¡¬è¿‡æ»¤
    score[~turn_ok.index.isin(turn_ok[turn_ok].index)] = -999
    score[~cap_mask.index.isin(cap_mask[cap_mask].index)] = -999
    # è¿”å›ä¸º dict
    return {k: float(v) for k, v in score.sort_values(ascending=False).items()}

# ------------------------------
# è°ƒä»“è®¡åˆ’
# ------------------------------
def plan_targets(context):
    # 1) åŸºç¡€æ± ï¼šå»ST/åœç‰Œ/é€€å¸‚/ä½ä»·
    base = base_universe(context)

    # 2) æˆäº¤é¢TopNï¼ˆé¿å…æµåŠ¨æ€§å‘ï¼‰
    base = top_by_turnover(context, base, g.UNIVERSE_TOP_N)

    # 3) æ‰“åˆ†
    scores = alpha_rank(context, base, asof_date=context.current_dt)
    if not scores:
        return []

    # 4) å–å‰HOLD_NUM
    pick = [sec for sec, _ in list(scores.items())[:g.HOLD_NUM]]
    return pick

# ------------------------------
# ä¸‹å•æ‰§è¡Œï¼ˆæ™ºèƒ½é™ä»· + æ‰‹æ•°å¯¹é½ + èµ„é‡‘å¯ç”¨ï¼‰
# ------------------------------
def order_target_value_smart(context, sec, target_value):
    """
    - ä¸ç”¨å¸‚ä»·å•ï¼Œå…¨éƒ¨è‡ªåŠ¨ç”Ÿæˆé™ä»·ï¼ˆé¿å…ç§‘åˆ›æ¿ä¿æŠ¤ä»·æŠ¥é”™ï¼‰
    - é™ä»·è‡ªåŠ¨å¡åœ¨å½“æ—¥æ¶¨è·ŒåœåŒºé—´å†…
    - æ•°é‡å¯¹é½æœ€å°æ‰‹æ•°ï¼Œä¸å¤Ÿä¸€æ‰‹å°±è·³è¿‡
    """
    cd = get_current_data()[sec]
    price = cd.last_price
    if price is None or np.isnan(price) or price <= 0:
        return

    low_lim  = cd.low_limit
    high_lim = cd.high_limit

    # å½“å‰æŒä»“
    pos = context.portfolio.positions.get(sec, None)
    cur_value = 0 if pos is None else pos.total_amount * price
    delta = target_value - cur_value

    if abs(delta) < 1e-6:
        return

    # æ–¹å‘
    if delta > 0:  # ä¹°å…¥
        # ä¹°å…¥é™ä»·ç•¥é«˜äºç°ä»·ï¼Œä½†ä¸è¶…è¿‡æ¶¨åœ
        limit_px = clamp(price * 1.02, low_lim * 1.000, high_lim * 0.999)
    else:          # å–å‡º
        # å–å‡ºé™ä»·ç•¥ä½äºç°ä»·ï¼Œä½†ä¸ä½äºè·Œåœ
        limit_px = clamp(price * 0.98, low_lim * 1.001, high_lim * 1.000)

    # ç›®æ ‡æ•°é‡
    tgt_amt = int(abs(delta) / max(limit_px, 1e-6))
    # æ‰‹æ•°å¯¹é½
    lot = min_lot(sec)
    tgt_amt = (tgt_amt // lot) * lot

    if tgt_amt <= 0:
        return

    # èµ„é‡‘æ£€æŸ¥ï¼ˆä¹°å…¥æ—¶ï¼‰
    if delta > 0:
        need_cash = tgt_amt * limit_px
        if context.portfolio.available_cash < need_cash * 1.001:
            return  # ä¸å¤Ÿå°±ä¸ä¸‹ï¼Œé¿å…â€œèµ„é‡‘æœ‰é™/è‡ªåŠ¨è°ƒå°å¯¼è‡´<ä¸€æ‰‹â€çš„æŠ¥é”™

        order(security=sec,
              amount=tgt_amt,
              style=LimitOrderStyle(limit_price=round(limit_px, 3)))
    else:
        # å–å‡ºæœ€å¤šä¸èƒ½è¶…è¿‡æŒä»“
        hold_amt = 0 if pos is None else pos.total_amount
        sell_amt = min(hold_amt, tgt_amt)
        sell_amt = (sell_amt // lot) * lot
        if sell_amt <= 0:
            return

        order(security=sec,
              amount=-sell_amt,
              style=LimitOrderStyle(limit_price=round(limit_px, 3)))

# ------------------------------
# é£é™©æ§åˆ¶ï¼ˆæ­¢ç›ˆ/æ­¢æŸ/è¿½è¸ªæ­¢ç›ˆï¼‰
# ------------------------------
def risk_control(context):
    cd = get_current_data()
    for sec, pos in context.portfolio.positions.items():
        if pos.total_amount <= 0:
            continue
        cost = pos.avg_cost
        if cost is None or cost <= 0:
            continue
        price = cd[sec].last_price
        if price is None or np.isnan(price) or price <= 0:
            continue
        ret = (price / cost - 1.0)

        # è®°å½•æŒä»“æœ€é«˜æµ®ç›ˆï¼ˆç”¨æŒä»“å¯¹è±¡çš„ self-defined memoï¼‰
        if not hasattr(pos, 'max_u'):
            pos.max_u = ret
        else:
            pos.max_u = max(pos.max_u, ret)

        # æ­¢æŸ
        if ret <= g.STOP_LOSS_PCT:
            # å–å‡ºå…¨éƒ¨
            order_target_value_smart(context, sec, 0)
            continue

        # å›ºå®šæ­¢ç›ˆ
        if ret >= g.TAKE_PROFIT_PCT:
            order_target_value_smart(context, sec, 0)
            continue

        # è¿½è¸ªæ­¢ç›ˆï¼ˆå›æ’¤è¶…è¿‡ TRAIL_PROFITï¼‰
        if pos.max_u >= g.TAKE_PROFIT_PCT * 0.6:  # è¾¾åˆ°ä¸€å®šæµ®ç›ˆåå†å¯åŠ¨è¿½è¸ª
            if (pos.max_u - ret) >= g.TRAIL_PROFIT:
                order_target_value_smart(context, sec, 0)
                continue

# ------------------------------
# æƒ…ç»ªåˆ†/æŒ‡æ ‡ï¼ˆå ä½ï¼Œä¿æŒä¸ä½ æ—¥å¿—ä¸€è‡´ï¼‰
# ------------------------------
def market_sentiment_placeholder(context):
    # ç®€åŒ–ï¼šå›ºå®š50åˆ† + æ¶¨åœ/è·Œåœå®¶æ•°ï¼ˆæ¼”ç¤ºæ—¥å¿—ï¼Œä¸å‚ä¸å†³ç­–ï¼‰
    limit_up = 2
    limit_dn = 2
    senti = 50.0
    log.info(f"æƒ…ç»ªåˆ†ï¼š{senti:.2f} æ¶¨åœæ•°ï¼š{limit_up} è·Œåœæ•°ï¼š{limit_dn}")
    return senti

# ------------------------------
# æ ¸å¿ƒæµç¨‹
# ------------------------------
def initialize(context):
    set_option('use_real_price', True)
    set_slippage(FixedSlippage(0.002))        # 0.2%æ»‘ç‚¹
    set_order_cost(OrderCost(open_tax=0, close_tax=0.001,
                             open_commission=0.0005, close_commission=0.0005,
                             close_today_commission=0, min_commission=5),
                   type='stock')

    # æ¯æ—¥è°ƒä»“
    run_daily(daily, time=g.REBALANCE_TIME)

def before_trading_start(context):
    pass

def daily(context):
    # 1) é£æ§å…ˆè·‘ï¼ˆæ¸…ç†è§¦å‘æ­¢ç›ˆ/æ­¢æŸçš„æŒä»“ï¼‰
    risk_control(context)

    # 2) è®¡åˆ’æŒä»“
    targets = plan_targets(context)  # list
    if not targets:
        return

    # 3) ç›®æ ‡æƒé‡
    max_w = g.MAX_WEIGHT
    n = min(len(targets), int((1.0 - g.CASH_KEEP) / max_w))
    picks = targets[:n]
    weights = {s: max_w for s in picks}

    # 4) æ‰§è¡Œè°ƒä»“
    total_value = context.portfolio.total_value
    # å…ˆæŠŠä¸åœ¨ç›®æ ‡é‡Œçš„å–æ‰
    for sec, pos in context.portfolio.positions.items():
        if pos.total_amount > 0 and (sec not in weights):
            order_target_value_smart(context, sec, 0)

    # å†ä¹°å…¥/åŠ ä»“ç›®æ ‡
    for sec, w in weights.items():
        order_target_value_smart(context, sec, total_value * w)

    # 5) æ—¥å¿—é‡Œçš„æƒ…ç»ªå ä½ï¼ˆä¸ä½ å›æµ‹æ—¥å¿—æ ¼å¼å¯¹é½ï¼‰
    market_sentiment_placeholder(context)

# ä¾›å¤–éƒ¨ç³»ç»Ÿç›´è¿çš„APIï¼ˆç¤ºä¾‹ï¼‰
def pick_for_my_oms(context):
    """
    å¤–éƒ¨äº¤æ˜“ç³»ç»Ÿå¯ç›´æ¥è°ƒç”¨ï¼š
    return: [(sec, score), ...]  æ‰“åˆ†ä»é«˜åˆ°ä½
    """
    base = top_by_turnover(context, base_universe(context), g.UNIVERSE_TOP_N)
    scores = alpha_rank(context, base, asof_date=context.current_dt)
    return list(scores.items())

